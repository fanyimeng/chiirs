import matplotlib.pylab as plt
from astropy.io import fits
import numpy as np
import sewpy
import aplpy as aplpy
import pandas as pd
import shapely.geometry as geo
from tqdm import tqdm


def polygon_reader(regfile):
    '''Read in *.reg file, in DS9 format. Convert the single-line
    polygon description to a set of sets of points pairs / geo.Polygon
    Args: 
        regfile: the input region file, should contains polygon description
            generated by ds9.
    Returns:
        list of shapely.geometry.Polygon()s.
    '''
    f = open(regfile, 'r')
    poly_list = []
    for line in f:
        if 'polygon(' in line:
            single_line_poly = line[line.find('(') + 1:line.find(')')]
            single_line_poly = np.array(list(map(float,
                                                 single_line_poly.split(','))))
            # print(single_line_poly)
            poly_x = single_line_poly[0::2]
            poly_y = single_line_poly[1::2]
            poly_list.append(geo.Polygon(np.array([poly_x, poly_y]).T))
    return poly_list


def sext_find(dataFile,
              rmsFile,
              regFile,
              outputName,
              plotImage=False,
              excludeReg=True):
    '''Using SEXtractor to identify cores in an image.
    Then filter out some cores based on ) RMS map, input as rmsFile.
    2) Regions input as regFile.
    3) Eccentricity of the fitted ellipses.

    Args:
        1) dataFile: the input FITS file.
        2) rmsFile: the RMS FITS file for filtering, should in same physical
          shape as the image FITS file.
        3) regFile: the regions files created in DS9, which contains lists ot
          2n floats that depict n points of a polygon.
        4) outputName: the root name of the output files. <outputName>.txt,
           the table of the params of the identified cores; <outputName.pdf>
           a plot of the image overlaid with the cores, in ellipses.
        5) plotImage: if you want to plot the image with cores overlaid
        6) excludeReg: if exclude the cores in large Hii regions defined by
            regFile.

    Returns:
        identified cores num and total cores num (before filtering)
    '''
    header = fits.open(dataFile)[0].header
    data = fits.open(dataFile)[0].data.T  # to make ra as x and dec as y
    rmshdu = fits.open(rmsFile)[0]
    rms = rmshdu.data.T  # to make ra as x and dec as y

    '''set up SEXtractor. The outputParameters dic will be used to store the
        filtered in cores.
    '''
    configParameters = ['X_IMAGE',
                        'Y_IMAGE',
                        'FLUX_RADIUS',
                        # 'FLUX_MAX',
                        'FLUX_ISO',
                        'FLUXERR_ISO',
                        'FLAGS',
                        'A_IMAGE',
                        'B_IMAGE',
                        'THETA_IMAGE',
                        'XPEAK_IMAGE',
                        'YPEAK_IMAGE',
                        'ALPHAPEAK_J2000',
                        'DELTAPEAK_J2000']
    sew = sewpy.SEW(params=configParameters,
                    config={'DETECT_MINAREA': 60,
                            'DETECT_MAXAREA': 2500 * 4,
                            'DETECT_THRESH': 5,
                            'BACK_SIZE': 32,
                            'BACKPHOTO_TYPE': 'LOCAL',
                            'BACKPHOTO_THICK': 24,
                            'THRESH_TYPE': 'RELATIVE',
                            'DEBLEND_MINCONT': 0.00001,
                            'DEBLEND_NTHRESH': 64,
                            'CHECKIMAGE_NAME': '../data/%s_check_rms.fits' % (outputName),
                            'CHECKIMAGE_TYPE': 'BACKGROUND_RMS'})
    ot = sew(dataFile)['table']

    '''SEXtractor returns half of maj/min-axis, plot uses full. sizeFactor
    adjust it in plot.
    '''
    sizeFactor = 2.0

    '''For a finite-size core, if you sum up all the pixels' flux density
    in unit of Jy/beam, then multiply this will give you the flux of the
    whole core. header['CDELTA#'] are the pixel intervels (sizes), which
    can be negative. header['BMAJ'] and header['BMIN'] are the beam sizes.
    '''
    fluxFactor = 4. * np.log(2.0) *\
        header['CDELT2'] * header['CDELT1'] /\
        (np.pi * header['BMAJ'] * header['BMIN'])
    fluxFactor = np.abs(fluxFactor * 1e3)  # convert Jy to mJy.

    '''create masks to filter out seudocores. All the masks are indicating
    the GOOD cores.
    '''
    maskDic = {}
    ot['FLUX_PEAK'] = np.ones_like(ot['FLUX_ISO'])
    ot['FLUXERR_PEAK'] = np.ones_like(ot['FLUX_ISO'])
    for ind in range(len(ot['FLUXERR_PEAK'])):
        ot['FLUX_PEAK'][ind] = data[
            ot['XPEAK_IMAGE'][ind],
            ot['YPEAK_IMAGE'][ind]]
        ot['FLUXERR_PEAK'][ind] = rms[
            ot['XPEAK_IMAGE'][ind],
            ot['YPEAK_IMAGE'][ind]]

    maskDic['size'] = ot["A_IMAGE"] < 0.1 / 2 * 50 / 2 / 0.05  # D/2/pixsize
    maskDic['rms'] = ot['FLUX_PEAK'] > 10. * ot['FLUXERR_PEAK']
    if excludeReg:
        maskDic['reg'] = np.ones_like(ot['A_IMAGE'])
        polygonSet = polygon_reader('large_hii_regions.reg')
        for ind in range(len(ot['A_IMAGE'])):
            point = geo.Point(ot['XPEAK_IMAGE'][ind],
                              ot['YPEAK_IMAGE'][ind])
            for poly in polygonSet:
                if point.within(poly):
                    maskDic['reg'][ind] = 0
                    ind = ind + 1

    maskIntersect = np.array(list(maskDic.values()))
    maskIntersect = np.prod(maskIntersect, axis=0)
    for maskItem in maskDic:
        print(maskItem, maskDic[maskItem].sum())

    ''' assign masked (positively) item of ot to outputParameters
    '''
    outputParameters = {}
    for parameter in list(ot.keys()):
        outputParameters[parameter] = ot[parameter].copy()[maskIntersect == 1]

    '''convert the outputPrameters dictionary to a Pandas DataFrame.
    '''
    outputDf = pd.DataFrame.from_dict(outputParameters, orient='columns')
    outputDf['FLUX_ISO'] = outputDf['FLUX_ISO'] * fluxFactor
    outputDf['FLUXERR_ISO'] = outputDf['FLUXERR_ISO'] * fluxFactor
    outputDf.to_csv('%s.csv' % outputName, index=False)

    if plotImage:
        fig = plt.figure()
        gc3 = aplpy.FITSFigure(dataFile, figure=fig, subplot=(1, 1, 1))
        gc3.recenter(x=266.8340, y=-28.3850, radius=3. / 60.)
        gc3.show_colorscale(cmap='gray', vmin=0.0, vmax=0.01, stretch='asinh')
        gc3.add_colorbar()
        gc3.colorbar.set_axis_label_text('Intensity (Jy/beam)')
        gc3.show_ellipses(ot['X_IMAGE'],
                          ot['Y_IMAGE'],
                          width=ot['A_IMAGE'] * sizeFactor,
                          height=ot['B_IMAGE'] * sizeFactor,
                          angle=ot['THETA_IMAGE'],
                          lw=0.1,
                          facecolor='none',
                          edgecolor=(0.5, 0.5, 1, 1),
                          coords_frame='pixel')
        gc3.show_ellipses(outputDf['X_IMAGE'],
                          outputDf['Y_IMAGE'],
                          width=outputDf['A_IMAGE'] * sizeFactor,
                          height=outputDf['B_IMAGE'] * sizeFactor,
                          angle=outputDf['THETA_IMAGE'],
                          lw=0.1,
                          facecolor='none',
                          edgecolor=(1, 0.5, 0.5, 1),
                          coords_frame='pixel')
        gc3.add_label(0.8, 0.92,
                      '%i / %i' % (len(outputDf['X_IMAGE']),
                                   len(ot['X_IMAGE'])),
                      relative='True',
                      color='gray',
                      size='small')

        fig.savefig('../plot/%s.pdf' % outputName, dpi=900)

    return len(ot['X_IMAGE']), len(outputDf['X_IMAGE'])


def get_010_flux_peak(data_010_file='',
                      data_006_file='',
                      rms_010_file='',
                      rms_006_file='',
                      table='',
                      output='',
                      label=''
                      ):
    data_010 = fits.open(data_010_file)[0].data.T
    data_006 = fits.open(data_006_file)[0].data.T
    rms_010 = fits.open(rms_010_file)[0].data.T
    rms_006 = fits.open(rms_006_file)[0].data.T
    df = pd.read_csv(table)
    f_peak_006 = []
    f_peak_010 = []
    e_peak_006 = []
    e_peak_010 = []
    for core_num in range(df.shape[0]):
        f_peak_006.append(data_006[int(df['XPEAK_IMAGE'][core_num]),
                                   int(df['YPEAK_IMAGE'][core_num])])
        f_peak_010.append(data_010[int(df['XPEAK_IMAGE'][core_num]),
                                   int(df['YPEAK_IMAGE'][core_num])])
        e_peak_006.append(rms_006[int(df['XPEAK_IMAGE'][core_num]),
                                  int(df['YPEAK_IMAGE'][core_num])])
        e_peak_010.append(rms_010[int(df['XPEAK_IMAGE'][core_num]),
                                  int(df['YPEAK_IMAGE'][core_num])])
    df['FLX_PEAK%s_006' % (label)] = np.array(f_peak_006) * 1e3
    df['FLX_PEAK%s_010' % (label)] = np.array(f_peak_010) * 1e3
    df['ERR_PEAK%s_006' % (label)] = np.array(e_peak_006) * 1e3
    df['ERR_PEAK%s_010' % (label)] = np.array(e_peak_010) * 1e3
    df.to_csv(table, index=False)
    return 0


def get_010_flux_ell(data_010_file='',
                     data_006_file='',
                     rms_010_file='',
                     rms_006_file='',
                     table='',
                     output='',
                     label=''):
    data_010 = fits.open(data_010_file)[0].data
    data_006 = fits.open(data_006_file)[0].data
    # data_010[data_010 < 0] = 0
    # data_006[data_006 < 0] = 0
    rms_010 = fits.open(rms_010_file)[0].data
    rms_006 = fits.open(rms_006_file)[0].data
    x1d = np.arange(0, data_006.shape[0])
    y1d = np.arange(0, data_006.shape[1])
    x2d = x1d[np.newaxis, :]
    y2d = y1d[:, np.newaxis]
    header_010 = fits.open(data_010_file)[0].header
    header_006 = fits.open(data_006_file)[0].header
    ang = 90 - header_006['BPA']
    beam_a = header_006['BMAJ'] * 3600. / 0.05
    beam_b = header_006['BMIN'] * 3600. / 0.05
    flxf006 = 4e3 * np.log(2.0) * header_006['CDELT2'] * header_006['CDELT1'] / (
        3.14159 * header_006['BMAJ'] * header_006['BMIN'])
    flxf010 = 4e3 * np.log(2.0) * header_010['CDELT2'] * header_010['CDELT1'] / (
        3.14159 * header_010['BMAJ'] * header_010['BMIN'])
    flxf006 = np.abs(flxf006)
    flxf010 = np.abs(flxf010)

    df = pd.read_csv(table)
    f_peak_006 = []
    f_peak_010 = []
    e_peak_006 = []
    e_peak_010 = []
    for core_num in tqdm(range(df.shape[0])):
        # mask = ((((x2d - int(df['XPEAK_IMAGE'][core_num])) * np.cos(np.radians(ang)) -
        #           (y2d - int(df['YPEAK_IMAGE'][core_num])) * np.sin(np.radians(ang))) /
        #          beam_a)**2 +
        #         (((x2d - int(df['XPEAK_IMAGE'][core_num])) * np.sin(np.radians(ang)) -
        #           (y2d - int(df['YPEAK_IMAGE'][core_num])) * np.cos(np.radians(ang))) /
        #          beam_b)**2
        #         ) < 1
        mask = ((x2d - int(df['XPEAK_IMAGE'][core_num]))**2 +
                (y2d - int(df['YPEAK_IMAGE'][core_num]))**2 < (0.83 / 0.05)**2)

        f_peak_006.append(data_006[mask].sum() * flxf006)
        f_peak_010.append(data_010[mask].sum() * flxf010)
        # e_peak_006.append(np.sqrt((rms_006[mask]**2).sum()) * flxf006)
        # e_peak_010.append(np.sqrt((rms_010[mask]**2).sum()) * flxf010)
        e_peak_006.append((rms_006[mask]).sum() * flxf006)
        e_peak_010.append((rms_010[mask]).sum() * flxf010)
    df['FLX_PEAK%s_006' % (label)] = f_peak_006
    df['FLX_PEAK%s_010' % (label)] = f_peak_010
    df['ERR_PEAK%s_006' % (label)] = e_peak_006
    df['ERR_PEAK%s_010' % (label)] = e_peak_010
    df.to_csv(table, index=False)
    return 0


# df = pd.read_csv('cores006.csv')
# for i in range(df.shape[0]):
#     point = geo.Point(df['XPEAK_IMAGE'][i], df['YPEAK_IMAGE'][i])
#     for poly in polygon_reader('large_hii_regions.reg'):
#         if point.within(poly):
#             i = i+1
#             print("in poly")
# print(sext_find(dataFile='../data/abcd_006_lpf_new.fits',
#                 rmsFile='../data/abcd_006_lpf_new_rms_100_1e-3_cubic.fits',
#                 regFile='large_hii_regions.reg',
#                 outputName='cores006',
#                 plotImage=True,
#                 excludeReg=True)
#       )
print(sext_find(dataFile='../data/rg_022.4.fits',
                rmsFile='../data/006_sex_test_check_rms.fits',
                regFile='large_hii_regions.reg',
                outputName='temp',
                plotImage=False,
                excludeReg=True)
      )




# print(sext_find(dataFile='../data/abcd_010_lpf_new.fits',
#                 rmsFile='../data/abcd_006_lpf_new_rms_100_1e-3_cubic.fits',
#                 regFile='large_hii_regions.reg',
#                 outputName='cores010',
#                 plotImage=True,
#                 excludeReg=True))

# get_010_flux_beam(data_006_file='../data/abcd_006_lpf_new.fits',
#                   data_010_file='../data/abcd_010_lpf_new.fits',
#                   rms_006_file='../data/cores006_check_rms.fits',
#                   rms_010_file='../data/cores010_check_rms.fits',
#                   table='cores006.csv')
